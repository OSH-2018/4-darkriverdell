# Meltdown Attack
## 原理
这里简要从理论层面说明Meltdown的攻击原理

### 分支预测&乱序执行

现代处理器基本上都包含流水线技术，而这种处理器处理分支指令时就会遇到一个问题，根据判定条件的真/假的不同，有可能会产生跳转，而这会打断流水线中指令的处理，因为处理器无法确定该指令的下一条指令。假如一直等待至分支语句执行完毕，对效率损失太大。因而就引进了分支预测，也就是对接下来可能执行的语句进行预测，提前执行。更先进的处理器则引入了乱序执行，也就是处理器根据各单元电路的空闲状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路执行。总之，在现代处理器中，位于后面的语句可能先于前面的语句执行，处理器只保证最终的结果与程序员设想的一致，而不保证具体执行的顺序一致。

### Cache

目前CPU主频已经达到3GHz以上，普遍采用多核并行，尽管主内存（DDR SDRAM）的主频已经达到2GHz—3GHz甚至更高，也无法完全满足多核CPU运行速度的需求，因为指令执行还是必须从内存中取指令，如果内存访问速度不够，CPU运行速度会受到内存访问速度的限制。

为了克服这个问题，目前采用在CPU与主内存之间插入多级高速缓存（Cache）的方法，Cache是一种访问速度极高的存储器，甚至可以集成在CPU内部，成为CPU微结构的一部分。Cache与主内存之间以块为单位交换数据，块长一般为数十字节。

###结合在一起

这里的重点是，缓存对程序员来说是完全不可见的，程序员（用户程序）不可能直接修改，或者直接读取缓存。故处理器在执行错误的语句之后，对程序状态进行回滚时，不会对缓存也进行回滚。也就是说，就算语句最后被“回滚”，对广义的CPU微结构还是有影响的——相应内存块已经读入到了Cache块。

这样的话，如果细心安排代码，就可以间接得到保护区域的数据。

##准备工作

### 检查 meltdown 补丁
使用[spectre-meltdown-checker](https://github.com/speed47/spectre-meltdown-checker.git)检查是否有 meltdown 补丁



### 关闭 meltdown 补丁
可以用注册表进行关闭。

## 代码的说明（lab4.c）

本代码参考了github.com/paboldin/meltdown-exploit/blob/master/meltdown.c的一部分内容，并进行了一些改写。
### 
```
pread(fd, buf, sizeof(buf), 0); //line29
int fd = open("/proc/version", O_RDONLY); //line104

```
这两行代码的目的是什么呢？为什么要反复读取/proc/version这一文件呢？
这应该说是一种讨巧的办法。/proc/version并不是一个文本文件，而是一个所谓的虚拟文件，当打开这一文件时，内核会调用一批函数并最终输出内核中的一块数据区域。而这个调用过程正好会读取到linux_proc_banner这个地址上的数据。也就是说，我们通过读取一些不受保护地数据把受保护的linux_proc_banner地址（即要攻击的地址）上的数据拿到了缓存上。
至于具体为什么要把将要攻击的数据拿到缓存上，我个人认为应该是要减少执行读取这些数据的指令的时间，从而使得读取指令之后的攻击指令被提前执行的概率的概率更大。

###具体攻击流程

分三步。Flush阶段，attack阶段以及Probe阶段
首先构建一个4096乘以256大小的数组

flush:清空这个数组在缓存中的痕迹

Speculate:见下文

probe：我们已知数组中有一个数在缓存中，其它都不在，这样我们只需将数组对应位置的数都读取一遍，看看哪个位置读取时间较短即可。这样我们就猜测出了一个受保护的地址上的数据

注1：4096是页的大小，这是防止相邻两个是一起被拿到缓存中<br>
注2：读取数组中的数采用了乱序遍历，防止编译器优化使攻击失败

###核心攻击代码
```<br>
"movzx (%[addr]), %%rax\n\t"
"shl $12, %%rax\n\t"
"mov (%[target], %%rax, 1), %%rbx\n\t"

```

这几行代码的目的是欺骗CPU的执行机制。第一行代码自然会产生段错误，但是由于读取的速度较快（前面我们已经把它拿到了缓存中），而检查它是否合法较慢，cpu很可能会执行后两行代码，
这样 读取的值乘以4096这个位置上的数就会被读取，**并拿到缓存中**，之后我们就可以进行probe

### 运行结果
```
1:%
2:s
3: 
4:v
5:e
6:r
7:s
8:i
9:o
10:n
11:
12:%
13:s

The result is %s version %s
